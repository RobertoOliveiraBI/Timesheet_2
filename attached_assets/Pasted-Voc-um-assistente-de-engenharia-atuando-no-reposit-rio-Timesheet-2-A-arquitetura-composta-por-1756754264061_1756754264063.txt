Você é um assistente de engenharia atuando no repositório Timesheet_2.
A arquitetura é composta por:

client/ – front-end React (não deve ser modificado).

server/ – API/serviços em Node.js + TypeScript.

shared/ – esquemas e tipos Drizzle (uso compartilhado; não modificar).

⚠️ Escopo: Todas as alterações desta tarefa devem ocorrer exclusivamente dentro de server/ (incluindo subpastas como server/scripts/, server/tests/, etc.).
Não renomeie, mova ou edite arquivos fora desse diretório.

1) Alvo da conexão (Azure SQL Server)
Driver: mssql (Node.js).

Variável de ambiente: adicionar MSSQL_URL em .env (não remover DATABASE_URL existente).

MSSQL_URL=mssql://ROBERTO:Sf544344$wedf@sql-prod-tractionfy.database.windows.net:1433/plataforma-tractionfy?encrypt=true
Use apenas MSSQL_URL dentro de server/.

2) Dependências (somente onde necessário)
No terminal:

npm i mssql debug
Usar debug com namespaces app:db e app:migrate.

Não adicionar bibliotecas fora de server/.

3) Tarefas
3.1 Conexão MSSQL
Arquivo: server/db.ts

Criar client MSSQL com pool reutilizável.

Ler process.env.MSSQL_URL; validar encrypt=true e trustServerCertificate=false.

3.2 Migração de estrutura e dados
Arquivo: server/scripts/migrateToMSSQL.ts

Conectar ao banco fonte (Postgres, já configurado via Drizzle) e ao destino (MSSQL).

Ler metadados do Postgres (via código em server/ usando information_schema ou shared/schema.ts).

Criar tabelas faltantes no SQL Server com mapeamento de tipos (ver Seção 4).

Transferir dados em lotes (1k–5k), usando transações por tabela.

Tratar nulos, normalizar numéricos, strings (trim) e datas (UTC).

Validar contagens origem × destino e registrar logs com debug('app:migrate').

3.3 Ajustes de dialeto SQL dentro de server/
Sempre que houver SQL literal ou helpers:

LIMIT x → OFFSET … ROWS FETCH NEXT … ROWS ONLY ou TOP (x).

RETURNING id → OUTPUT INSERTED.id.

now() → SYSUTCDATETIME().

ILIKE → LIKE com COLLATE Latin1_General_CI_AI ou LOWER(col) LIKE LOWER(@q).

TRUE/FALSE → BIT (1/0).

ON CONFLICT → MERGE … WHEN MATCHED/NOT MATCHED.

jsonb → NVARCHAR(MAX) + ISJSON() opcional.

uuid → UNIQUEIDENTIFIER.

serial/bigserial → IDENTITY(1,1).

Esses ajustes aplicam-se a arquivos como server/storage.ts, server/routes.ts, server/seed.ts e quaisquer outros dentro de server/ que contenham SQL/postgres hardcoded.

3.4 Verificações de robustez
Garantir existência de tabelas essenciais no novo banco (users, campaigns, clients, etc.).

Listagens: endpoints/queries de listagem em server/ devem retornar registros sem erro.

CRUD: testar criação, edição e inativação (soft-delete) com tratamento de nulos, formatação numérica e normalização de strings.

3.5 Logs e Debug
debug('app:db') para conexão/queries.

debug('app:migrate') para migração.

Nunca logar segredos.

Exemplo de execução com logs:

DEBUG=app:* node server/scripts/migrateToMSSQL.js
3.6 Testes automatizados mínimos
Criar em server/tests/db.mssql.spec.ts:

Conexão abre/fecha pool MSSQL.

INFORMATION_SCHEMA.TABLES confirma existência de tabelas (users, categories, clients etc.).

CRUD básico em users:

Create → Read → Update → Inativar (flag/deleted_at) → List paginada.

Listagens reais em users, categories, clients.

Executar testes:

DEBUG=app:* npm test
4) Mapeamentos de tipos (PostgreSQL → SQL Server)
PostgreSQL	SQL Server
serial/bigserial	INT/BIGINT IDENTITY(1,1)
uuid	UNIQUEIDENTIFIER
boolean	BIT (0/1)
text/varchar	NVARCHAR(n) ou NVARCHAR(MAX)
json/jsonb	NVARCHAR(MAX) + ISJSON() opcional
timestamp tz	DATETIMEOFFSET
timestamp sem tz	DATETIME2
numeric(x,y)	DECIMAL(x,y)
Arrays	Tabela auxiliar ou NVARCHAR(MAX) com JSON
5) Exemplos (dentro de server/)
Conexão MSSQL (server/db.ts)
import sql from 'mssql';
import createDebug from 'debug';

const debug = createDebug('app:db');
let pool: sql.ConnectionPool | null = null;

export async function getMssql() {
  if (pool) return pool;
  const connStr = process.env.MSSQL_URL;
  if (!connStr) throw new Error('MSSQL_URL ausente no .env');

  debug('Conectando ao MSSQL (pool)...');
  pool = await new sql.ConnectionPool(connStr).connect();
  debug('MSSQL conectado.');
  return pool;
}
Helper de paginação (LIMIT → OFFSET/FETCH)
export function buildOffsetFetch(page = 1, pageSize = 20) {
  const p = Math.max(1, page);
  const ps = Math.max(1, pageSize);
  const offset = (p - 1) * ps;
  return ` OFFSET ${offset} ROWS FETCH NEXT ${ps} ROWS ONLY `;
}
Insert com retorno de ID
const pool = await getMssql();
const req = pool.request();
req.input('nome', sql.NVarChar(200), payload.nome?.trim() ?? null);
const result = await req.query(`
  INSERT INTO usuarios (nome)
  OUTPUT INSERTED.id
  VALUES (@nome)
`);
const newId = result.recordset[0].id;
Upsert (ON CONFLICT → MERGE)
await pool.request().query(`
MERGE usuarios AS tgt
USING (SELECT @id AS id, @nome AS nome) AS src
ON (tgt.id = src.id)
WHEN MATCHED THEN UPDATE SET nome = src.nome
WHEN NOT MATCHED THEN INSERT (id, nome) VALUES (src.id, src.nome);
`);
6) Script de migração (estrutura + dados)
Arquivo: server/scripts/migrateToMSSQL.ts

Passos:

Conectar no Postgres (via db.ts atual) e no MSSQL (getMssql()).

Ler information_schema no Postgres e gerar DDL equivalente no MSSQL.

Para cada tabela:

Criar no destino se não existir.

Copiar dados em lotes (1k–5k) com conversões:

boolean → BIT

datas → toISOString() / DATETIMEOFFSET

json → JSON.stringify (ISJSON opcional)

strings → trim()

Verificar contagens e logar com debug('app:migrate').

Recriar índices essenciais (PK/UK/FK) ao final.

Rodar:

ts-node server/scripts/migrateToMSSQL.ts
# ou
node server/scripts/migrateToMSSQL.js
Segurança: sem logs de credenciais; usar try/catch com mensagens claras.

7) Testes funcionais exigidos
Implementados em server/tests/:

Conexão: abrir/fechar pool MSSQL.

Schema: INFORMATION_SCHEMA.TABLES confirma users, categories, clients, etc.

CRUD users: Create → Read → Update → Inativar → List paginada.

Listagens: users, categories, clients retornam registros sem erro.

Executar com:

DEBUG=app:* npm test
8) Critérios de aceite
Alterações apenas em server/.

Conexão usa MSSQL_URL e requer encrypt=true.

Tabelas essenciais existem no SQL Server.

Listagens sem LIMIT ou ILIKE.

CRUD (criar/editar/inativar) com tratamento de nulos, numéricos, strings.

Migração transfere estrutura + dados com contagens logadas.

Nenhuma credencial exposta nos logs.

9) Entregáveis
server/db.ts – pool MSSQL.

server/scripts/migrateToMSSQL.ts.

Ajustes T-SQL em arquivos dentro de server/.

server/tests/*.spec.ts – testes MSSQL.

server/README.md – instruções de migração e testes.

Observação: O projeto usa Drizzle ORM (configurado com @neondatabase/serverless para PostgreSQL). Todos os mapeamentos para SQL Server devem ser implementados apenas dentro de server/, sem impactar client/ ou shared/. Em caso de SQL Postgres hardcoded, substitua por soluções compatíveis com MSSQL somente dentro desse diretório.